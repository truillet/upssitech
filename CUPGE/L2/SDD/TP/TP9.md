# TP 9¬†: JNI et langage C/Java

JNI (**J**ava **N**ative **I**nterface) est une biblioth√®que logicielle d‚Äôinterfa√ßage qui permet au code Java s‚Äôex√©cutant √† l‚Äôint√©rieur de la JVM (**J**ava **V**irtual **M**achine) d‚Äôappeler et d‚Äô√™tre appel√© par des applications natives (c‚Äôest-√†-dire des programmes sp√©cifiquement li√©s au mat√©riel et au syst√®me d‚Äôexploitation de la plate-forme concern√©e), ou avec des biblioth√®ques logicielles bas√©es sur d‚Äôautres langages (C, C++, assembleur, etc.).

Il faut installer tout d‚Äôabord le JDK Java et instancier la variable **JAVA\_HOME** (exemple ci-dessous pour Linux) ([^1]) :

```console
sudo apt install openjdk-17-jdk-headless
export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64
```

## Un premier exemple
### 1.1 Etape 1 : Cr√©er le fichier java
Dans un premier temps, cr√©ons le fichier HelloJNI.java (cf. ci-dessous).

```java
package fr.ut3; class HelloJNI {
  static {System.loadLibrary("Greetings");} // librairie native public static native String getGreetings(String who);
  public static void main(String[] args) {
    HelloJNI h = new HelloJNI();
    System.out.println(getGreetings(args[0]));
  }
}
```

### 1.2 Etape 2 : compiler le fichier java
Dans un 2√®me temps, compilons le fichier (attention √† bien utiliser l‚Äôoption **-d**)
```console
javac -d . HelloJNI.java
```

Normalement, le fichier HelloJNI.class est cr√©√© dans le sous-r√©pertoire : fr/ut3

### 1.3 Etape 3 : g√©n√©rer le fichier .h
L‚Äôusage de la commande suivante va permettre de g√©n√©rer les headers .h (√† ne pas modifier) qui vont permettre de coder les fonctions en C et/ou C++

```console
javac -h . HelloJNI.java (pour Java 8 et sup√©rieur) qui va g√©n√©rer le code fr_ut3_HelloJNI.h
```

Code g√©n√©r√©¬†:
```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>

/* Header for class fr_ut3_HelloJNI */
#ifndef _Included_fr_ut3_HelloJNI
  #define _Included_fr_ut3_HelloJNI

  #ifdef cplusplus
    extern "C" {
  #endif

  /*
  * Class: fr\_ut3\_HelloJNI
  * Method: getGreetings
  * Signature: (Ljava/lang/String;)Ljava/lang/String;
  */
  JNIEXPORT jstring JNICALL Java_fr_ut3_HelloJNI_getGreetings (JNIEnv*, jclass, jstring);

  #ifdef cplusplus
    }
  #endif
#endif
```

### 1.4 Etape 4 : cr√©er le fichier .c
Enfin, il faut coder le programme .c qui va impl√©menter les fonctions natives (par exemple dans le fichier Greetings.c

```c
// Greetings.c
#include <jni.h>
#include "fr_ut3_HelloJNI.h"

JNIEXPORT jstring JNICALL Java_fr_ut3_HelloJNI_getGreetings (JNIEnv* env, jclass obj, jstring string) {
  const char* str = (*env)->GetStringUTFChars(env,string,0); char cap[128];
  // strcpy(cap, str);
  sprintf(cap, "You welcome, %s\n", str);
  (*env)->ReleaseStringUTFChars(env, string, str);
  return ((*env)->NewStringUTF(env, cap));
}
```

### 1.5 G√©n√©rer la librairie dynamique
Derni√®re √©tape, g√©n√©rons la librairie dynamique (**.so** sous Unix, **.dll** sous windows) gr√¢ce aux deux commandes suivantes [^2]¬†:
```console
gcc -c -I"$JAVA\_HOME/include" -I"$JAVA\_HOME/include/linux" -o Greetings.o Greetings.c gcc -shared -o libGreetings.so Greetings.o
```

### 1.6 Ex√©cuter le programme
Enfin il suffit d‚Äôex√©cuter le programme en donnant en argument o√π trouver les librairies natives. Normalement, un message s‚Äôaffiche¬†üòä
```console
java -Djava.library.path=. fr.ut3.HelloJNI Guy
```

## Les transtypages
Le mapping entre les types java et ceux des m√©thodes natives est assez simple. Le sch√©ma de nommage reste √† peu les m√™mes : les types natifs sont pr√©c√©d√©s du caract√®re ¬´¬†**j**¬†¬ª suivi par le nom en minuscules √©quivalent en java. JNI inclut un autre type nomm√© ¬´¬†*jsize¬†¬ª* qui stocke la longueur d‚Äôun tableau ou d‚Äôune chaine de caract√®res.

| **Type de donn√©es Java** | **Type de donn√©es natif** | **Description** |
| --- | --- | --- |
| void | void | Type vide |
| Byte | jbyte | 8 bits sign√©s. Valeurs entre -27 √† 27- 1 |
| Int | jint | 32 bits sign√©s. Valeurs entre -231 et 231- 1 |
| float | jfloat | 32 bits. Repr√©sente une valeur r√©elle entre 1,4 1045 et 3,4 1038 (approx.), positive ou n√©gative |
| double | jdouble | 64 bits. Repr√©sente une valeur r√©elle entre 4,9 10324 et 1,7 10308 (approx.), positive ou n√©gative |
| char | jchar | 16 bits non sign√©s. Valeur entre 0 et 65535 |
| long | jlong | 64 bits sign√©s. Valeur entre -263 et 263-1 |
| short | jshort | 16-bit sign√©s. Valeur entre -215 et 215‚Äì1 |
| boolean | jboolean | 8 bits non sign√©s. *true* et *false* |

En outre, JNI d√©finit d‚Äôautres r√©f√©rences classiques comme les cha√Ænes de caract√®res, classes, ‚Ä¶ D‚Äôautres r√©f√©rences peuvent aussi √™tre mapp√©es et manipulables avec ***jobject***.

| **Type de R√©f√©rence Java** | **Type JNI** | **Description** |
| --- | --- | --- |
| java.lang.object | jobject | N‚Äôimporte quel objet Java |
| java.lang.String | jstring | Repr√©sentation des cha√Ænes de caract√®res |
| java.lang.Class | jclass | classe objet Java |
| java.lang.Throwable | jthrowable | Objet Java levant une exception |

## A vous de jouer !!!
A vous maintenant de cr√©er votre interface JNI.

Vous devrez g√©rer une liste de valeurs enti√®res tri√©es dans une **liste cha√Æn√©e en C**. Chaque cellule de la liste poss√®de deux champs :

1. un champ *valeur* pour stocker une valeur enti√®re,
2. et un champ *suivant* pour stocker l‚Äôadresse de la cellule suivante.

On s‚Äôint√©resse ici aux listes tri√©es dans l‚Äôordre croissant : on sait donc que le premier √©l√©ment de la liste est le plus petit, le second est le deuxi√®me plus petit, etc.

Par exemple, la liste suivante est correcte :


Votre programme Java devra impl√©menter les fonctions natives suivantes :

* une fonction **creerListe()** qui cr√©√© une liste
* la fonction **ajouter(entier x)** qui ajoute une cellule (au bon endroit pour que la liste reste tri√©e) dans la liste
* une fonction **supprimer(entier x)** qui supprime une valeur de la liste
* une fonction **tester(entier x)** qui renvoie vrai si il existe une cellule dans L contenant la valeur x, et faux sinon.
* Et une fonction **compter()** qui compter le nombre d‚Äô√©l√©ments de la liste

Vous √©crirez enfin un programme java appelant ces fonctions natives (en utilisant ou non une interface graphique)

[^1]: Sous MacOS, lancer la commande /usr/libexec/java\_home pour trouver le chemin vers la JDK
[^2]: Sous MacOS, remplacer "$JAVA_HOME/include/linux" par "$JAVA_HOME/include/darwin")

