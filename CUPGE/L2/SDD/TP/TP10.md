# TP 10Â : un middleware pour les connecter tousÂ !

## 1. Introduction
Ivy est un bus logiciel [middleware](https://www.eei.cena.fr/products/ivy) conÃ§u Ã  la DTI/DGAC (ex CENA) dans le but de connecter dâ€™une maniÃ¨re **extrÃªmement simple** des applications **interactives** ou pas en elles Ã©crites avec diffÃ©rents langages et fonctionnant sur diffÃ©rentes machines ou plates-formes.

Il sâ€™agit dâ€™un modÃ¨le de communication **compatible avec la programmation Ã©vÃ©nementielle** classique des interfaces graphiques. En un sens, ce bus logiciel implÃ©mente une approche multi-agentsÂ : les agents apparaissent, Ã©mettent des messages et en reÃ§oivent, les traitent puis quittent le bus sans bloquer les autres agents prÃ©sents. Ivy vise principalement Ã  faciliter le dÃ©veloppement rapide de nouveaux agents, et Ã  en contrÃ´ler une collection dynamique.

Par opposition Ã  certains autres bus logiciels, ivy ne se fonde pas sur un serveur central ou un annuaire qui permet de Â«Â routerÂ Â» les demandes dâ€™un agent. Au lancement, tous les agents se prÃ©sentent Ã  un point de rendez-vous, le reste est transparent pour le programmeurÂ !
En fait, le rÃ´le dâ€™ivy est **principalement dâ€™Ã©tablir une convention de communication entre applications**. Les messages sont Ã©changÃ©s **sous une forme textuelle**, et la sÃ©lection des messages rÃ©cupÃ©rÃ©s ou non par les agents est basÃ©e sur les expressions rationnelles (*regexp* en anglaisÂ ; famille de notations compactes et puissantes pour dÃ©crire certains ensembles de chaÃ®nes de caractÃ¨res).

**A quoi cela peut-il bien servirÂ ?** 
Bien que limitÃ© *Ã  des Ã©changes de messages textuels*, ce principe permet de prototyper trÃ¨s rapidement des applications hautement interactives (en rÃ©-utilisant des agents dÃ©jÃ  dÃ©veloppÃ©s) voire de concevoir des systÃ¨mes adaptÃ©s spÃ©cifiquement aux besoins dâ€™une personne, tout cela indÃ©pendamment du systÃ¨me.
Par exemple, pour un systÃ¨me qui aurait Ã  afficher du texte sur un Ã©cran, on peut trÃ¨s facilement remplacer cet affichage par un synthÃ©tiseur vocal sans faire aucun changement au cÅ“ur du systÃ¨me, qui se contenterait dâ€™envoyer sur le bus de lâ€™information Ã  donner aux utilisateurs.

Les bibliothÃ¨ques Â«Â ivyÂ Â» sont disponibles sur diffÃ©rents systÃ¨mes dâ€™exploitation (Sun Solaris, Linux, Win\*, WinCE, Mac OS, Android, â€¦) pour plusieurs langages de programmation (C, C++, C#, Java, Perl, Perl-Tk, Tcl, Tcl-Tk, Ada, Python, O-Caml, COM, VBA, Adobe Flash, â€¦). [cf. **https://github.com/truillet/ivy**]

## 2. Fonctionnement en langage C
Quel que soit le langage utilisÃ©, les principes de fonctionnement restent les mÃªmes. 4 opÃ©rations sont couramment utilisÃ©esÂ :
1. CrÃ©ation dâ€™un nouvel acteur du bus
2. Connexion au bus
3. Envoi / rÃ©ception des messages (par un mÃ©canisme dâ€™abonnement)
4. Fermeture de la connexion et destruction du bus

### 2.1 crÃ©ation dâ€™un nouvel acteur du bus
Cela revient ici Ã  allouer de la mÃ©moire pour lâ€™objet qui va se connecter au bus.

```c
IvyInit ("IvyTranslater", "Hello le monde", 0, 0, 0, 0);
```
Ici, lâ€™agent apparaÃ®tra sur le bus sous le nom de Â«Â **IvyTranslater**Â Â» et enverra le message Â«Â *Hello le monde*Â Â» dÃ¨s quâ€™il sera connectÃ©.

### 2.2 connexion
Le bus ivy se connecte sur un port dâ€™une adresse IP (ou de broadcast) du rÃ©seau localÂ : câ€™est le point de rendez-vous de tous les agents.
â€œ*Lâ€™adresse ivy*â€ en elle-mÃªme se divise en 2 partiesÂ : **adresse_IP** et **adresse_port**

Lâ€™adresse IP Ã  utiliser est au choix lâ€™adresse de *loopback* (@ IP 127.0.0.1) propre Ã  chaque machine, lâ€™adresse dâ€™une machine du rÃ©seau auquel on appartient (exÂ : 192.168.0.1) ou une adresse de *broadcast* (solution Ã  prÃ©fÃ©rer)

**NotaÂ :** Une adresse IP se divise elle-mÃªme en deux sections, lâ€™adresse du rÃ©seau et lâ€™adresse de la machine. Lâ€™adresse de broadcast est la derniÃ¨re adresse adressable sur un rÃ©seau. Typiquement pour un rÃ©seau de classe C, cette adresse est de la forme xxx.xxx.xxx.255 et pour un rÃ©seau de classe B xxx.xxx.255.255 avec â€œxxxâ€¦ â€, lâ€™adresse du rÃ©seau.

Lâ€™adresse 127.0.0.1 a la particularitÃ© dâ€™Ãªtre lâ€™adresse locale de la machine appelÃ©e localhost.*

Il est Ã  noter que lâ€™utilisation dâ€™ivy nâ€™est pas possible sur internet mais reste limitÃ© au rÃ©seau local auquel on appartient (il existe cependant des solutions permettant de passer dâ€™un sous-rÃ©seau Ã  un autre)
Le choix du port nâ€™a pas dâ€™importance particuliÃ¨re Ã  partir du moment oÃ¹ le port sÃ©lectionnÃ© est libre (i.e. non utilisÃ© par un autre service[[1]](#footnote-1)). Typiquement (et par dÃ©faut dans les implÃ©mentations dâ€™ivy), le port â€˜2010â€™ est utilisÃ© mais on peut utiliser plusieurs bus Ã  divers ports en mÃªme temps.
```c
IvyStart ("127.255.255.255:2010");
```
Ivy est Â«Â lancÃ©Â Â» sur le rÃ©seau Ã  lâ€™adresse 127.255.255.255 sur le port 2010.

### 2.3 envoi et rÃ©ception de messages
#### 2.3.1 envoi dâ€™un message
Lâ€™envoi de messages est extrÃªmement simpleÂ : il suffit de prÃ©parer la chaÃ®ne alphanumÃ©rique de donnÃ©es que lâ€™on souhaite diffuser puis on active la fonction IvyS*endMsg* associÃ©e au bus crÃ©Ã© prÃ©cÃ©demment.
```c
strcpy(arg, "Robert")Â ;
IvySendMsg ("Bonjour %s", arg);
```

Le message â€œ*Bonjour Robert*â€ est envoyÃ© sur le bus.

#### 2.3.2 abonnement et rÃ©ception dâ€™un message
Pour recevoir des messages du bus, il est nÃ©cessaire de sâ€™abonner Ã  des Â«Â *patrons*Â Â» de messages qui permettront lâ€™activation dâ€™une fonction dite de *callback* qui traitera le message reÃ§u.
```c
IvyBindMsg (HelloCallback, 0, "^Hello (.\*)");
```

Tous les messages de la forme Â«Â Hello *quelque chose*Â Â» seront traitÃ©s par la fonction HelloCallback.

### 2.4 fermeture de la connexion
Enfin la fermeture du bus permet de clore proprement lâ€™Ã©change de donnÃ©es. En voici encore un exempleÂ :
```c
IvyStop();
```
Lâ€™agent se dÃ©connecte du bus logiciel.

### 2.5 attente des Ã©vÃ©nements
La derniÃ¨re instruction du programme principal correspond au lancement de la boucle dâ€™attente dâ€™Ã©vÃ©nements provenant du rÃ©seau.
```c
IvyMainLoop();
```

## 3. Exercices
Avant de dÃ©buter, assurez-vous que les librairies ivy pour votre distribution ont Ã©tÃ© compilÃ©es.
Si ce nâ€™est pas le cas, allez lÃ  ğŸ¡ª **https://github.com/truillet/ivy** et compilez la librairie (Ã  ne faire que la premiÃ¨re fois)

### 3.1 ivyprobe
*ivyprobe* est un petit outil trÃ¨s utile dÃ©veloppÃ© pour ivy qui va vous permettreÂ :

* de vÃ©rifier la prÃ©sence dâ€™agents sur le rÃ©seau
* de Â«Â voirÂ Â» les messages envoyÃ©s par chacun dâ€™eux
* et de simuler des messages envoyÃ©s par des agents

Ouvrez deux terminaux Unix, positionnez-vous dans le rÃ©pertoire ivy et tapez la commande Â«Â ivyprobe '(.\*)'Â Â».


Les agents se mettent par dÃ©faut Ã  lâ€™Ã©coute sur le rÃ©seau (du type 127.255.255.255 sur le port 2010).
Que se passe-t-ilÂ ? Tapez dans la premiÃ¨re fenÃªtre Â«Â *salut*Â Â». Que se passe-t-il dans la seconde fenÃªtreÂ ?

### 3.2 Ecoute
Nous allons maintenant coder notre premier agent en langage C. TÃ©lÃ©chargez le fichier [_c.zip](https://github.com/truillet/ivy/blob/master/code/example\_c.zip), dÃ©zippez-le et compilez le code source en tapant la commandeÂ :
```console
gcc Ecoute.c libivy.a libprce.a -o Ecoute
```

Tapez maintenant Â«Â ./EcouteÂ Â»
Ouvrez maintenant un terminal et tapez Â«Â ivyprobe '^(.\*)'Â Â». Envoyez la commande Â«Â *Hello tout le monde*Â Â». Que se passe-t-ilÂ ?
Recommencez en modifiant la commande envoyÃ©e.
Envoyez maintenant la commande Â«Â ***Bye***Â Â». Que se passe-t-ilÂ ?
Analysez le code dâ€™Ecoute.c. Essayez de suivre le cheminement de la rÃ©ception dâ€™un message Ã  sa rÃ©Ã©mission.

## 4. vos propres applications ...
Maintenant, il ne reste quâ€™Ã  concevoir et dÃ©velopper vos propres applicationsÂ !

1. Ã©crivez un programme qui Â«Â *Ã©coute*Â Â» tous les messages envoyÃ©s sur le rÃ©seau qui commencent par Â«Â **L2_CUPGE_UPSSITECH**Â Â» et les affichent Ã  lâ€™Ã©cran.
2. Ã©crivez un programme qui Ã©coute les messages du type Â«Â Multiplie **x** **y**Â Â» (oÃ¹ **x** et **y** sont des arguments reprÃ©sentant des entiers) et qui renvoie le rÃ©sultat de la multiplication.
3. (**OPTIONNEL**) Ã©tendez ce dernier programme Ã  toutes les opÃ©rations de base (addition, soustraction, multiplication et division entiÃ¨re)

## 5. vos propres applications ... avec celles des autres
Il est bien Ã©videmment possible de discuter avec les programmes Ã©crits par dâ€™autres et mÃªme surtout Ã©crits avec dâ€™autres langages comme Java, Python, â€¦
En se connectant sur une adresse de *broadcast* sur le rÃ©seau local, vous pouvez recevoir et Ã©mettre des Ã©vÃ©nements Ã  tous les agents Â«Â ivyÂ Â» connectÃ©s (vous pouvez aussi utiliser des adresses de multicast comme 224.0.0.0).

Nous allons utiliser un agent dÃ©jÃ  dÃ©veloppÃ© en java. Avant dâ€™effectuer cela, assurez-vous quâ€™un serveur X est lancÃ© (pas de problÃ¨mes normalement sous Unix ou MacOS ou Windows 11 avec WSL2).

Sous Windows 10, sous pouvez utiliser le serveur X (**VcXsrv**)[https://sourceforge.net/projects/vcxsrv] [^2]

**Nota**Â : Si vous utilisez WSL 2 avec Windows 10 ou 11, pensez Ã  rajouter les commandes suivantes dans le fichier *.bashrc*

```console
export DISPLAY=$(awk '/nameserver / {print $2; exit}' /etc/resolv.conf 2>/dev/null):0
export LIBGL\_ALWAYS\_INDIRECT=1
```

TÃ©lÃ©chargez Ã  lâ€™adresse https://github.com/truillet/ivy/blob/master/code/ivyGUI.zip le fichier ivyGUI.zip. DÃ©zippez le. Une fois ce fichier sur votre rÃ©pertoire courant, tapez la commande suivante dans votre consoleÂ :

```java
java -cp .:ivyGUI-1.3.jar:ivy-java-1.2.17.jar fr.irit.diamant.ivyGUI.ivyGUI &
```
Une fenÃªtre graphique vide doit apparaÃ®tre sur votre Ã©cran.

A lâ€™aide dâ€™ivyprobe, envoyez successivement les commandes suivantesÂ :

```java
ivyGUI CreerTexte=L2 CUPGE UPSSITECH:BOLD:30
ivyGUI CreerChamps=2:nombre 1:nombre 2:Multiplie
```

Vous devriez visualisez la figure ci-contre.
Remplissez les champs et appuyez sur Â«Â ***Multiplie***Â Â».

Dans ivyprobe, vous devriez voir apparaÃ®tre une commande du style
de celle prÃ©sentÃ©e ci-dessous

```java
ivyGUI Champs1.content=champ\_0-**x**Â :champ\_1-**y**:
```
oÃ¹ **x** et **y** sont les nombres entrÃ©s dans lâ€™interface graphique

Modifier votre programme multiplie.c de telle maniÃ¨re quâ€™il sâ€™abonne au message prÃ©cÃ©dent et renvoie la commande suivanteÂ :

ivyGUI CreerTexte=Resultat -> **z**:ITALIC:14 oÃ¹ **z** est le rÃ©sultat de la multiplication de x par y

[^1]: Les ports 1 Ã  1024 sont rÃ©servÃ©s par le systÃ¨me pour les services Â«Â bien connusÂ Â» (well known ports) comme http (port 80), ftp (port 21), ...
[^2]: Voir **https://medium.com/@japheth.yates/the-complete-wsl2-gui-setup-2582828f4577**

